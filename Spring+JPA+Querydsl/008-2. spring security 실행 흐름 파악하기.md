## Spring Security 실행 흐름 파악하기

---
Spring Security 와 jwt토큰 설정을 위해 내가 추가했던 `JwtFilter`, `TokenProvider`, `SecurityConfig`, `JwtSecurityConfig`에 log를 찍어놓았다.  
실행하고 호출하면서 찍히는 log들을 보면서 어떤식으로 흐름이 이어지는지 파악해보고자 한다.  
  
### 1. 서버만 실행한 경우
<img src="https://user-images.githubusercontent.com/93504767/148902004-334f3c72-20e2-4247-b47f-d5166033018d.png">  

**(1) TokenProvider - afterPropertiesSet()**  
TokenProvider는 `InitializingBean`인터페이스를 implements하고 있기때문에 해당 메소드를 재정의해야한다.  

afterPropertiesSet() 은 InintializingBean 인터페이스의 메소드로 BeanFactory에 의해 모든 property 가 설정되고 난 뒤 실행되는 메소드다.  
주로 실행시점의 custom 초기화 로직이 필요하거나 주입받은 property 를 확인하는 용도로 사용된다고 한다.  
`InitailiaingBean`은 Spring에서 기본적으로 제공하는 인터페이스다. 이 인터페이스를 이용하여 해당메소드를 재정의하면 Spring이 알아서 초기화시점에 호출해준다.  
  

사실 나는 `@PostConstruct`에 대해서만 알고있었는데, 알고보니 해당 어노테이션은 자바9이상부터는 Deprecated라 사용하지 않는것을 권장하고 그 대신에 이 `afterPropertiesSet()`메소드를 재정의하여 사용해야한다.
  
내가 작성한 afterPropertiesSet()은 실행시점의 custom초기화 로직을 위해 작성했다.  
```java
@Override
public void afterPropertiesSet() throws Exception {
    byte[] keyBytes = Decoders.BASE64.decode(secret);
    this.key = Keys.hmacShaKeyFor(keyBytes);
    log.info(">>> [TokenProvider] afterPropertiesSet --- key : " + this.key);
}
```
HMAC-SHA 알고리즘을 이용하여 jwt토큰을 생성할 때 사용하는 key값을 초기화해놓는다.  
  
**(2) SecurityConfig - configure**  
SecurityConfig는 `WebSecurityConfigurerAdapter`를 extends하고 있는데, 여기서 Spring Security의 기본적인 설정들을 해준다.  
configure를 override해서 설정을 추가해주었다.  
```java
@Override
public void configure(WebSecurity web) throws Exception {
    web.ignoring().antMatchers("/favicon.ico");

    web.ignoring().antMatchers("/swagger/**", "/swagger-ui.html", "/swagger-resources/**", "/webjars/**", "/v2/api-docs");
}

@Override
protected void configure(HttpSecurity httpSecurity) throws Exception {
    log.info(">>> [SecurityConfig] configure");
    
    httpSecurity
        .csrf().disable() // jwt토큰 인증방식을 사용할 것이기 때문에 csrf방식은 disable처리 해준다.
        .cors() // CORS를 허용한다는 설정을 해준다.
        .and()

        // exceptionHandling할 때 우리가 추가했던 
        // jwtAuthenticationEntryPoint와 jwtAccessDeniedHandler로 설정해준다.
        .exceptionHandling()
        .authenticationEntryPoint(jwtAuthenticationEntryPoint)
        .accessDeniedHandler(jwtAccessDeniedHandler)
        .and()
        
        // security는 기본적으로 Session을 사용하는데, 우리는 Session을 사용하지 않으니 STATELESS 처리를 해준다.
        .sessionManagement()
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
        
        // 요청의 종류에 따라 인증되어야 접근가능한지, 누구나 접근가능한지에 대해 설정해준다.
        .authorizeRequests() // security 처리에 HttpServletRequest를 사용한다
        .antMatchers("/api/**").authenticated()
        .anyRequest().permitAll()
        .and()
        
        // JwtFilter에 설정해놓은 필터를 등록해준다. --> 여기서 세번째 로그가 찍힌다!
        .apply(new JwtSecurityConfig(tokenProvider));

}
```
**(3) JwtSecurityConfig - configure**   
위에서 spring security에 대한 기본 설정을 할때 맨 마지막에 `.apply(new JwtSecurityConfig(tokenProvider)`가 호출되면서 해당 로그가 찍히게 된다.  
  
`JwtSecurityConfig`는 우리가 생성한 Filter를 등록해주는 역할을 한다.  
```java
@Override
public void configure(HttpSecurity http) throws Exception {
    log.info(">>> [JwtSecurityConfig] configure --- http에 customFilter(JwtFilter)추가");
    JwtFilter customFilter = new JwtFilter(tokenProvider);
    http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
}
```  
`UsernamePasswordAuthenticationFilter` 전에 우리가 생성한 JwtFilter가 호출되도록 설정해줬다.
  
##
### 2. 로그인 API 호출
형식에 맞춰서 데이터를 넣고 login을 시도하면 아래와 같은 로그가 찍힌다.  
<img src="https://user-images.githubusercontent.com/93504767/149048805-3b58eae4-3ed9-4472-9423-0cc21409487e.png">
<img src="https://user-images.githubusercontent.com/93504767/149048877-6799f019-b68f-4a5e-ac37-5b1e02fc38f4.png">  
  
**(1) JwtFilter - doFilter**  
요청이 들어왔을 때 Filter를 가장 먼저 통과하기때문에 첫번째사진과 같은 로그가 찍히게된다.  
로그인에 대한 요청이기때문에 아직 발급받은 토큰이 없어서 헤더에 저장된 토큰 정보도 없다.  
doFilter 내에서 `resolveToken`을 호출하여 헤더에 저장된 토큰정보를 꺼내왔을 때 해당 값이 null로 나오게된다.
```java
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    log.info(">>> [JwtFilter] doFilter 실행");
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    String jwt = resolveToken(request);  // header에서 jwt를 받아온다.String requestURI = request.getRequestURI();
    log.info(">>> [JwtFilter] doFilter --- {jwt : " + jwt + "}, {requestURI : " + requestURI+"}");

    if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
        // token이 유효하다면 토큰으로부터 Autentication을 받아와 SecurityContext에 저장한다.
        Authentication authentication = tokenProvider.getAuthentication(jwt);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        log.info("Security Context에 '{}' 인증정보를 저장했습니다. >>> uri : {}", authentication.getName(), requestURI);
    } else {
        log.info("유효한 JWT 토큰이 없습니다. >>> uri : {}", requestURI);
    }

    filterChain.doFilter(servletRequest, servletResponse);
}
```
따라서 String jwt = null 인 상태이기 때문에 조건문을 통과하지못해서 유효한토큰이 없다는 로그까지 찍히게 된다.  
  

여기서 유의해야할 점은 마지막에 `filterChain.doFilter(servletRequest, servletResponse)` 이 부분이다.  
이 코드를 까먹지말고 반드시 작성해줘야한다. 이를 작성해주지 않으면 서블릿으로 요청이 넘어가지 않게된다.  

    +) FilterChain  
    일단 FilterChain 인터페이스 안에도 doFilter라는 메소드가 있다.  
    이 메소드는 일반 필터들이 상속받는 Filter인터페이스의 `doFilter()`(현재 JwtFilter의 doFilter)와는 다른 메소드다.  



