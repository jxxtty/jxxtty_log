## [코틀린 쿡북] 레시피 5 - 컬렉션
코틀린은 자바와 다르게 중개자 역할을 하는 컬렉션을 거치지 않고 여러가지 메소드를 컬렉션 클래스에 직접 추가한다.  
  



---
### 레시피 5.1 배열 다루기
배열을 생성할 때는 `arrayOf`함수(팩토리 메소드)를 이용해 배열을 만들고 `Array` 클래스에 들어있는 속성과 메소드를 이용해 배열에 들어있는 값을 다룬다.  
```kotlin
val strings = arrayOf("this", "is", "kotlin", "array")
val nullStringArray = arrayOfNulls<String>(5) // null로만 채워진 배열도 생성할 수 있다.
```
코틀린에서 배열에 접근할 때 사용하는 문법은 자바와 동일하지만, 코틀린에서 Array는 `클래스`다.  
- Array 클래스에는 **public 생성자가 하나**만 있다.  

<img width="715" alt="스크린샷 2022-01-26 오전 10 36 46" src="https://user-images.githubusercontent.com/93504767/151088585-90a8bde3-0725-4fd4-a6d6-c404d394754b.png">  
두번째 인자로 받는 람다는 배열을 생성할 때 인덱스마다 호출된다.  
  
예를들어, 처음 5개의 정수를 제곱한 값의 문자열 배열을 생성하는 코드는 다음과 같다.  
```kotlin
val squares = Array(5){i -> (i * i).toString()}
for(item in squares) print("$item ") // 0 1 4 9 16
```  
- 배열에 접근하여 값을 받아오고, 값을 변경할 때는 자바와 동일하게 `squares[1]`이런식으로 호출하게 되는데, 이는 내부적으로 Array클래스의 `get`과 `set`메소드를 이용하는 것이다.  
  

- 또, 코틀린에는 `오토박싱(autoboxing)`과 `언박싱(unboxing)` 비용을 방지할 수 있는 기본 타입을 나타내는 클래스가 있다.  
`arrayOf`로 타입을 지정하지 않고 생성하는 배열 외에도 기본 타입을 지정해서 생성하는 `booleanArrayOf`, `byteArrayOf`, `shortArrayOf`, `charArrayOf`, `intArrayOf`, `longArrayOf`, `floatArrayOf`, `doubleArrayOf`와 같은 메소드도 제공한다.  
  

- Array클래스에는 두어 개의 고유한 **확장함수**가 존재한다.  

[1] 주어진 배열에 인덱스 값을 알고싶다면, Array의 `indices` 속성을 사용한다.  
```kotlin
val indices = squares.indices
println(indices) // 0..4
```
  
[2] 배열을 순회할 때 인덱스값도 같이 필요하다면 `withIndex` 함수를 사용한다.  
```kotlin
for((index, value) in squares.withIndex()) {
    println("Index $index maps to $value")
}
// Index 0 maps to 1
// Index 1 maps to 1
// Index 2 maps to 4
// Index 3 maps to 9
// Index 4 maps to 16
```
  
##
### 레시피 5.2 컬렉션 생성하기  
  
자바와 동일하게 코틀린에서 지원하는 컬렉션에는 List, Set, Map이 있다.  
자바와 다른점은 변경 가능한 컬렉션과 변경 불가능한 읽기 전용 컬렉션이 나뉜다는 점이다.  
변경 불가능한 컬렉션을 생성할 땐 `listOf`, `setOf`, `mapOf` 메소드를 사용하여 생성하고,  
변경 가능한 컬렉션을 생성할 땐 `mutableListOf`, `mutableSetOf`, `mutableMapOf` 메소드를 사용하여 생성한다.  
(변경 불가능하다는 것은 컬렉션에 원소를 추가하거나 삭제할 수는 없지만, 컬렉션에 들어있는 객체는 수정 가능하다)  
  
  
```kotlin
// 변경 불가능한 읽기 전용 컬렉션
var numList = listOf(3, 1, 4, 1, 5, 9)
var numSet = setOf(3, 1, 4, 1, 5, 9) // set은 중복을 허용하지 않는다 -> numSet.size == 5
var numMap = mapOf(1 to "one", 2 to "two", 3 to "three") // Pair인스턴스를 이용해 생성한다
```
```kotlin
// 변경 가능한 컬렉션
var numList = mutableListOf(3, 1, 4, 1, 5, 9)
var numSet = mutableSetOf(3, 1, 4, 1, 5, 9)
var numMap = mutableMapOf(1 to "one", 2 to "two", 3 to "three")
```
+) `mapOf` 메소드는 다음과 같이 정의되어 있다.  
<img width="722" alt="스크린샷 2022-01-26 오전 11 08 43" src="https://user-images.githubusercontent.com/93504767/151091761-eb55181d-0084-4534-b89f-e6205b49a871.png">  
파라미터로 `Pair` 인스턴스 타입의 가변 인자 리스트를 받는다.  
따라서 `to(중위 연산자 함수)`는 map 항목을 생성하는 데 사용된다.  
  
  
자바와 비슷하게 List, Set, Map 인터페이스를 직접 구현한 클래스의 인스턴스도 생성할 수 있다.  
```kotlin
val list = LinkedList<Int>()
list.add(33)
list.add(11)
list.addLast(999) // addLast의 별칭 -> add (add메소드 == addLast메소드)
println(list) // [33, 11, 999]
list[2] = 44
list.addAll(listOf(1,2,3,4))
println(list) // [33, 11, 44, 1, 2, 3, 4]
```
  
##
### 레시피 5.3 컬렉션에서 읽기 전용 뷰 생성하기  
변경 가능한(mutable) List, Set, Map이 있을 때 해당 컬렉션의 읽기 전용 버전을 생성하고 싶다면, `toList`, `toSet`, `toMap` 메소드를 사용한다.  
기존 컬렉션을 바탕으로 읽기 전용 뷰를 만들려면 List, Set, Map 타입의 변수에 기존 컬렉션을 할당하면 된다.  
  
두가지 방식의 차이점은 다음과 같다.  
- `toList`, `toSet`, `toMap`을 사용하는 방법  
 : 해당 메소드를 사용한 시점에 컬렉션에 들어있는 값들만 읽기 전용 버전을 생성한다.  
추후에 해당 컬렉션에 값이 변경되더라도 읽기 전용 버전에는 반영되지 않는다.  
이 메소드들은 독립된 객체를 생성하는데 독립된 객체의 내용은 원본과 같지만, **원본이 수정된다면 더 이상 같은 객체를 나타내지는 않는다**.
  

- List, Set, Map타입의 변수에 기존 컬렉션을 할당하는 방법  
 : 할당해준 컬렉션을 기준으로 읽기 전용 버전이 생성된다.  
추후에 해당 컬렉션에 값이 변경되면 읽기 전용 버전에도 적용된다.  
  
```kotlin
// 첫번째 방법(toList, toSet, toMap 사용)
val mutableNums = mutableListOf(1, 2, 3, 4)
val readOnlyNumList: List<Int> = mutableNums.toList()
println(mutableNums == readOnlyNumList) // true

mutableNums.add(5)
println(mutableNums == readOnlyNumList) // false
println(mutableNums) // [1, 2, 3, 4, 5]
println(readOnlyNumList) // [1, 2, 3, 4]


// 두번째 방법(기존 컬렉션을 할당)
val readOnly: List<Int> = mutableNums
println(mutableNums == readOnly) // true

mutableNums.add(6)
println(mutableNums == readOnly) // true
println(mutableNums) // [1, 2, 3, 4, 5, 6]
println(readOnly) // [1, 2, 3, 4, 5, 6]
```
  
##
### 레시피 5.4 컬렉션에서 맵 만들기
  
키 리스트가 있을 때 각각의 키와 생성한 값을 연관시켜서 맵을 만들고 싶다면 `associateWith`함수에 각 키에 대해 실행되는 람다를 제공해 사용한다.  
  
```kotlin
val keys = 'a'..'f'
val map = keys.associateWith { item ->
        item.toString().repeat(5)
        .replaceFirstChar { if (item.isLowerCase()) item.titlecase(Locale.getDefault()) else item.toString() }}
println(map) // {a=Aaaaa, b=Bbbbb, c=Ccccc, d=Ddddd, e=Eeeee, f=Fffff}

val map2 = keys.associateWith { it.toString().repeat(3) } // it 을 사용할 수도 있다.
println(map2) // {a=aaa, b=bbb, c=ccc, d=ddd, e=eee, f=fff}
```
+) `replaceFirstChar`로 사용한 코드는 `capitalize()`가 사장된 문법이라 대체해서 사용한 것이다.  
  
##
### 레시피 5.5 컬렉션이 빈 경우 기본값 리턴하기










